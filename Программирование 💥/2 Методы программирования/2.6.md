# Контейнерный класс vector. Основные методы, примеры использования

##### <span style="background:#d3f8b6">Контейнерный класс vector</span>

<span style="background:rgba(240, 200, 0, 0.2)">Контейнерный класс  (контейнер)</span> - это класс, который помогает удобно хранить и работать с коллекцией объектов. У каждого контейнера есть готовые методы для работы с этими объектами.

<span style="background:#d3f8b6">Вектор</span> - это контейнер, который содержит коллекцию объектов <font color="#6425d0">одного типа</font> <font color="#a5a5a5">(только целые числа, или только символы и тд) </font>и представляет собой <font color="#d83931">динамический массив</font>, который может автоматически изменять свой размер по мере необходимости.

Для использования вектора надо подключить библиотеку:
`#include <vector>`

**Объявление вектора:**
```cpp
// 1. пустой вектор произвольного размера
vector <тип_элемента> имя_вектора;
vector <int> myVector;

// 2. пустой вектор указанного размера
vector <тип_элемента> имя_вектора(размер);
vector <int> myVector(10);

// 3. вектор указанного размера и его инициализация начальным значением
vector <тип_элемента> имя_вектора(размер, значение);
vector <int> myVector(10, 0); // 0 0 0 0 0 0 0 0 0 0

// 4. вектор указанного размера и его инициализация разными значениями
vector <int> myVector = {1, 2, 3, 4, 5};
```

###### <font color="#f79646">Что такое итераторы?? </font> 
Для работы с контейнерами, в том числе и с вектором, используются<font color="#0070c0"> итераторы</font>.
С помощью них можно перебирать элементы контейнера, не вникая в его реализацию.

`Краткое предисловие.. Можно не читать :) 
`Зачем мне какие-то там итераторы, если я могу использовать int i = 0 в цикле? 
`Да, в векторе использовать итератор при переборе элементов необязательно, потому что память там последовательная, как в обычном массиве, и когда делаешь myVector[i+1], то по сути ты просто прибавляешь несколько битов к адресу от нулевого элемента, но если взять контейнер лист? Там связное распеределение памяти, и мы не можем просто так взять и прибавить к адресу какое-то кол-во битов, там же у нас ссылка на след элемент, и вот чтобы в этом не копаться придумали итераторы. 
`Так зачем итератор в векторе? Ну, во-первых, это удобно, потому что у всех контейнеров есть одинаковые методы для итераторов, также итераторы содержатся в параметрах некоторых методов.` 

<font color="#00b050">Некоторые методы с итераторами:</font>
`begin()` - возвращает итератор, который установлен на начало контейнера
`end()` - возвращает итератор, который установлен ЗА последнем элементом контейнера
`rbegin()` - возвращает итератор, который установлен на последнем элементе.
`rend()` - возвращает итератор, который установлен ПЕРЕД первым элементом.
###### <font color="#6425d0">Перебор элементов вектора</font>
Есть два способа перебрать элементы, через индекс и через итератор:

```cpp
// 1. Перебор через индекс
for (int i = 0; i < myVector.size(); ++i) {
    cout << myVector[i] << " ";
}

// 2. Перебор через итератор
for (vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it) {
    // разыменовывем, чтобы получить значение, на которое указывает итератор
    cout << *it << " ";  
} 
```

##### <span style="background:rgba(205, 244, 105, 0.55)">Методы работы с вектором</span>

1. `push_back (element)` - добавить элемент в конец вектора
2. `pop_back()` - удалить элемент с конца вектора

```cpp
//Например
myVector.push_back(10)
myVector.pop_back()
```

3. `empty()` - проверка пустой вектор или нет (true если пустой)
4. `size()` - текущее количество элементов в векторе
5. `capacity()` - количество элементов, которые могут поместиться в вектор без реорганизации памяти
6. `clear()` - очистить вектор, при этом оставить его размерность

```cpp
//Например
myVector.size()
myVector.clear()
```

7. `insert` (3 модификации) - вставка элементов

```cpp
// 1. вставляем указанное значение в позицию, определенную итератором
insert (it, value);
myVector.insert (myVector.begin(), 10);
myVector.insert (myVector.begin()+5, 7); // на 5 позизию (счет с 0)

// 2. вставляем несколько элементов указанного значения в позицию, определенную итератором
insert (it, count, value);
myVector.insert (myVector.begin(), 3, 10);

// 3. здесь все три параметра - итераторы
// вставляем диапазон элементов на позицию определенную it
// начиная с first_it и заканчивая last_it (last_it не включая)
myVector.insert (it, first_it, last_it);
// Один понятный пример
vector <int> myVector = {0, 1, 2, 3, 4, 5, 6, 7};
myVector.insert (myVector.begin(), myVector.begin()+3, myVector.begin()+6);
// в итоге имеем вектор: 3 4 5 0 1 2 3 4 5 6 7 
//(то есть в начало просто вставили 3 элемента)

```

8. `erase` (2 модификации) - удалить элемент

```cpp
// 1. удаление элемента с позиции определенной итератором
erase(it);
myVector.erase(myVector.begin()+3);

// 2. удаление диапазона элементов 
// начиная с позиции first_it, и заканчивая last_it (не включая last_it)
erase(first_it, last_it);
myVector.erase(myVector.begin(), myVector.begin()+2);
```

9. `resize` (2 модификации) - изменения размера вектора
```cpp
// 1. изменение размера вектора до какого-то числа
resize(count);
//Если размер вектора < count, то он увеличится до count, 
// а если > count, то уменьшится до count

// 2. изменение размера вектора до какого-то числа,
// но в случае увеличения размера элементы заполняются значением value
resize(count, value);

myVector.resize(25);
myVector.resize(100, 0);

```

##### <span style="background:rgba(205, 244, 105, 0.55)">Пример использования вектора</span> 
Просто создадим вектор, заполним 3 элементами, отсортируем и выведем

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Создаём вектор целых чисел
    vector<int> myIntVector;

    // Добавим элементы
    myIntVector.push_back(15);
    myIntVector.push_back(5);
    myIntVector.push_back(10);

	// Отсортируем элементы
    sort(myIntVector.begin(), myIntVector.end());

    // Выводим элементы
    for (int i = 0; i < myIntVector.size(); i++) {
        cout << myIntVector[i] << " ";
    }

    // Вывод: 5 10 15
    return 0;
}
```