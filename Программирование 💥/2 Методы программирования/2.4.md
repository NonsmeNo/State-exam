# Связное распределение памяти. Однонаправленные списки. Построение однонаправленного списка. Двунаправленные списки. Построение двунаправленного списка.

##### <span style="background:#fdbfff">Связное распределение памяти</span>

<span style="background:#affad1">Связное распределение памяти</span> — это способ организации данных в памяти, при котором каждый элемент содержит указатель на следующий элемент. То есть данные **не хранятся последовательно** <font color="#a5a5a5">(например как в массиве)</font>, а могут быть разбросаны по разным участкам памяти, но связаны друг с другом.
<font color="#de7802">Преимущество </font>в том, что связное распределение памяти позволяет:
динамически изменять размер структуры, а также вставлять и удалять элементы без необходимости сдвига остальных.
<font color="#6425d0">Недостаток</font> в том, что необходимо дополнительное место под хранение адреса соседнего элемента.

##### <span style="background:rgba(205, 244, 105, 0.55)">Однонаправленные списки</span>
Это динамическая структура данных, где каждый элемент (узел) списка представлен двухкомпонентной записью: данные элемента и указатель на следующий элемент (то есть его адрес).

![[Pasted image 20250520153554.png]]

<span style="background:#fff88f">Например</span>
![[Pasted image 20250520160345.png]]

Первый элемент списка называется <font color="#92d050">голова</font>, последний - <font color="#e36c09">хвост</font>. Зная адрес головы списка можно получить доступ к любому элементу списка.

<font color="#6425d0">NULL</font> - константа, которая обозначает неопределенный адрес. Она говорит, что элемент в списке последний.
`указатель == NULL` будет true, только если мы явно присвоили элементу в указателе NULL

Чтобы получить доступ к полю какого-то элемента, зная его адрес используют стрелочку <font color="#ff0000">оператор</font> `->`.
`x -> info`, или `x->next`
Это запись аналогична `(*x).info`, просто работы со списками принято использовать стрелочки.

###### <span style="background:rgba(240, 107, 5, 0.2)">Построение однонаправленного списка</span>

<font color="#92d050">Структура узла однонаправленного списка</font> 
```cpp
struct list 
{
	int info; // данные
	list* next; // указатель на след элемент списка
}
```

<font color="#e36c09">Методы работы с однонаправленным списком</font>
1. Инициализация списка
```cpp
list* init(int x)
{
	list* h = new list; // выделяем память под элемент головы списка
	h->info = x; // присваиваем полю данные значение x
	h->next = NULL; // пока что это конец списка
	return h; // возвращаем адрес головы списка
}
```

2. Добавление элемента в конец списка
```cpp
void add(list* h, int x)
{
	list* p = h; // создаем временную ячейку в значении которой адрес h
	while (p->next != NULL)
		p = p->next; // идем до последнего элемента списка

	list* l = new list; // выделяем память под новый элемент списка
	l->info = x; // присваиваем полю данные значение x
	l->next = null; // ссылаемсям на "пустоту" так как это последний элемент
	p->next = l; // в поле указателя предыдущего элемента ставим l
}
```

3. Вывод списка на экран
```cpp
void print(list* h)
{
	list* p = h;
	while (p != NULL) // просто проходимя по всем элементам от головы до хвоста 
	{
		cout << p->info << endl;
		p = p->next;
	}
}
```

4. Удаление отрицательных элементов
```cpp
list* del(list* h)
{
	list* p = h;
	
	//тут идем до предпоследнего элемента, потому что в if проверяется следующий
	while (p->next != NULL)
	{
		if (p->next->info < 0)
		{
			list* temp = p->next; // временный указатель на след элемент
			p->next= p->next->next; // указываем на через элемент
			delete temp; //очищаем блок памяти под элемент
		}
		else
		{
			p = p->next;
		}
	}

	// отдельно проверяем голову
	if (h->info < 0)
	{
		list* temp = h;
		h = h->next;
		delete temp; //очищаем блок памяти прошлой головы
	}
	return h;
}
```

Теперь в main инициализируем список и выполним все вышеуказанные функции
```cpp
int main()
{
	list* head = init(10);
	add(head, 15);
	add(head, -20);
	add(head, 25);
	add(head, -3);
	// создали список 10 15 -20 25 -3
	
	head = del(head); // удалили отрицательные элементы
	print(head); // выводим список: 10 15 25
}
```

##### <span style="background:rgba(205, 244, 105, 0.55)">Двунаправленные списки</span>

Двунаправленный список отличается от однонаправленного тем, что у узла двунаправленного списка еще присутствует указатель на предыдущий элемент

<span style="background:#fff88f">Например</span>
![[Pasted image 20250520161352.png]]

###### <span style="background:rgba(240, 107, 5, 0.2)">Построение двунаправленного списка</span>

<font color="#92d050">Структура узла двунаправленного списка</font> 
```cpp
struct list 
{
	lшые* prev; // указатель на пред элемент списка
	int info; // данные
	list* next; // указатель на след элемент списка
}
```


<font color="#e36c09">Методы работы с двунаправленным списком</font>
1. Инициализация списка
```cpp
list* init(int x)
{
	list* h = new list; // выделяем память под элемент головы списка
	h->info = x; // присваиваем полю данные значение x
	h->prev = NULL;
	h->next = NULL; 
	return h; // возвращаем адрес головы списка
}
```

2. Добавление элемента в конец списка
```cpp
void add(list* h, int x)
{
	list* p = h; // создаем временную ячейку в значении которой адрес h
	while (p->next != NULL)
		p = p->next; // идем в конец списка

	list* l = new list; // выделяем память под новый элемент списка
	l->info = x; // присваиваем полю данные значение x
	l->prev = p; // указываем на предыдущий элемент
	l->next = null; // ссылаемсям на "пустоту" так как это последний элемент
	p->next = l; // в поле указателя предыдущего элемента ставим l
}
```

3. Вывод списка на экран (один в один как в однонаправленном)
```cpp
void print(list* h)
{
	list* p = h;
	while (p != NULL) // просто проходимся по всем элементам от головы до хвоста 
	{
		cout << p->info << endl;
		p = p->next;
	}
}
```

4. Удаление отрицательных  элементов
```cpp
list* del(list* h)
{
	// начинаем со следующего элемента!!! 
	// так как будем удалять текущий, а не следующиq, как в однонаправленном
	list* p = h->next; 
	while (p != NULL)
	{
		if (p->info < 0) // проверяем значение текущего элемента
		{
			list* temp = p;
			p = p->next; // чтобы не зациклилось, когда мы удалим текущий элемент
			
			temp->prev->next = temp->next;
			temp->next->prev = temp->prev;
			delete temp; //очищаем блок памяти под элемент
		}
		else
		{
			p = p->next;
		}
	}

	// отдельно проверяем голову
	if (h->info < 0)
	{
		list* temp = h;
		h = h->next;
		h->prev = NULL;
		delete temp; //очищаем блок памяти прошлой головы
	}
	return h;
}
```

Теперь в main инициализируем список и выполним все вышеуказанные функции
```cpp
int main()
{
	list* head = init(10);
	add(head, 15);
	add(head, -20);
	add(head, 25);
	add(head, -3);
	// создали список 10 15 -20 25 -3
	
	head = del(head); // удалили отрицательные элементы
	print(head); // выводим список: 10 15 25
}
```
