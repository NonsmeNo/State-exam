# Базовые принципы ООП

ООП основывается на <font color="#6425d0">ЧЕТЫРЁХ</font> ключевых принципах, которые помогают структурировать и упростить разработку программ.

#### <span style="background:rgba(205, 244, 105, 0.55)">Абстракция</span>

Принцип ООП, при котором мы **выделяем только важные характеристики объекта**, необходимые для решения конкретной задачи, и **игнорируем всё лишнее**.
Мы **не описываем всю сложность объекта**, а берём **только нужные поля и методы**.

<span style="background:rgba(240, 200, 0, 0.2)">Например:</span> есть класс Программист
Для задачи управления персоналом нам важны только некоторые <font color="#245bdb">поля и методы</font>:
 `язык_программирования`
 `опыт_работы`
 `работать()`
 Мы **не будем описывать** такие детали, как любимая музыка или умение готовить — они не влияют на нашу задачу.

Подсказать нам, какие методы нужны для нашей реализации, помогает **интерфейс**. Интерфейс показывает **важные методы**, которые нужны для взаимодействия с объектом.

#### <span style="background:rgba(205, 244, 105, 0.55)">Инкапсуляция</span>

Принцип ООП, который заключается в **сокрытии внутренних полей класса и некоторых методов** от внешнего кода внутри этого класса.  
Поля и методы делают **приватными** — то есть доступными только внутри этого класса, и обратиться к ним можно только через **публичные методы** (например, геттеры и сеттеры).
Это помогает **защитить данные от неправильного использования**. 

<span style="background:rgba(240, 200, 0, 0.2)">Например:</span> есть объект банковский счёт,  который хранит баланс. Вдруг кто-то возьмет, и присвоит балансу отрицательное число, а такого быть не должно. 
Поэтому, вместо обращения к полю на прямую, создают сеттер, который не просто присваивает значение, а ещё проверяет условия, в нашем случае, что баланс не может стать отрицательным.

#### <span style="background:rgba(205, 244, 105, 0.55)">Наследование </span>

Принцип ООП, который заключается в том, что можно создавать новые классы на основе уже существующих — при этом новые классы **наследуют** свойства и методы родительского класса, а также могут добавлять свои уникальные характеристики. А еще методы наследуемые от родительского класса можно переопределить в производном классе.
Это сильно облегчает понимание и масштабирование кода. Не нужно много раз **переписывать** в разных объектах одни и те же свойства. Достаточно унаследовать эти объекты от одного «родителя», и «родительские» свойства применятся автоматически.


<span style="background:rgba(240, 200, 0, 0.2)">Например:</span>  
Есть базовый класс **персонаж**, у которого есть общие свойства: здоровье и скорость, а также метод перемещения.
От него наследуются классы различных типов персонажей, например, **Рыцарь**, **Лучник** и **Маг**.
У каждого из этих персонажей добавляются свои методы, рыцарь атакует в ближнем бою, лучник издалека, а маг магией пуляется.
И нам не надо с нуля прописывать каждого персонажа, а просто унаследовать класс такого абстрактного персонажа-пустышку.

В java один класс наследуется от другого с помощью `extends`,
переопределять методы можно с помощью `@Override`.

```java
class Character {
    void move() {
        System.out.println("Персонаж ходит");
    }
}

class Fairy extends Character {
    @Override
    void move() {
        System.out.println("Фея летает ✨");
    }
}
```


#### <span style="background:rgba(205, 244, 105, 0.55)">Полиморфизм</span>

Принцип ООП, который позволяет использовать один и тот же метод для разных типов объектов, но у каждого типа объекта этот метод будет иметь разную реализацию.

<span style="background:rgba(240, 200, 0, 0.2)">Например: </span>
Мы можем сделать цикл, где у каждого персонажа вызывается метод **атаковать**. И каждый персонаж будет атаковать по-своему, с разной силой и эффектом, в зависимости от типа персонажа
Если бы не было полиморфизма, пришлось бы писать отдельный код для атаки магов, отдельно для эльфов, отдельно для фей и тд. Код получился бы очень большим и непонятным.

```java
public class Main {
    public static void main(String[] args) {
    
        // ссылаемся на класс обычного персонажа 
        //(в таком случае видны только общие функции всех персонажей)
        Character[] party = {
            new Mage(),
            new Elf(),
            new Fairy()
        };

        for (Character character : party) {
            character.attack();  // Каждый вызовет свою версию attack()
        }
        // после этого объект можно привести к определенному типу
        // например персонажа маг именно к типу маг, чтобы были доступны
        // функции для мага ...
    }
}

// Вывод
// Маг колдует мощное заклинание!
// Эльф стреляет из лука!
// Фея бросает волшебный заряд!
```
